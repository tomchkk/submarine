#!/usr/bin/env bash

source "$SERVICE/config-service"

__submodule_service_git_path="$GIT_PATH"
__submodule_service_submodules_dir="$SUBMODULES_DIR"
__submodule_service_submodules_path="$GIT_PATH/$SUBMODULES_DIR"

##
# Recursively adds a git submodule and its dependencies to a project.
##
submodule_service::add() {
    local super_module="$1"
    local options="${@:2}"
    local super_path=$(for option in ${options[@]}; do :; done; echo "$option")

    git submodule add ${options[@]}

    local super_name=$(config_service::get_name_for_path "$super_path")

    if "$super_module"; then
        config_service::add_key "$super_name" "super" true
    fi

    local dependencies=($(__submodule_service::get_dependencies_for_path "$super_path"))
    local dependency_path
    for dependency_path in ${dependencies[@]}; do
        dependency_path=${dependency_path/$super_path\/}
        echo "Adding dependency '$dependency_path' for '$super_path'"

        local dependency_name=$(config_service::get_name_for_path "$dependency_path" "$super_path")

        if ! $(config_service::get_configured_paths | grep -q "$dependency_path"); then
            local dependency_options=(
                --branch $(config_service::get_branch_for_path "$dependency_path" "$super_path")
                --name "$dependency_name"
                --
                $(config_service::get_repo_for_path "$dependency_path" "$super_path")
                "$dependency_path"
            )

            submodule_service::add false "${dependency_options[@]}"
        else
            echo "'$dependency_path' is already required"
        fi

        # update dependency config
        config_service::add_key "$super_name" "dependency" "$dependency_name"
        config_service::add_key "$dependency_name" "super" "$super_name"
    done
}

##
# Gets an array of dependency paths for a given submodule path.
##
__submodule_service::get_dependencies_for_path() {
    local path="${1:?"A path is required"}"
    local states=($(git submodule status --recursive $path))
    local dependencies=()

    for state in "${states[@]}"; do
        case "$state" in
            **/**)
                if [[ "$state" != "$path" ]]; then
                    dependencies+=("$state")
                fi
            ;;
        esac
    done

    echo ${dependencies[@]}
}

##
# Installs the submodule for a path.
##
submodule_service::install_path() {
    local path=${1:?"A submodule path is required"}

    git submodule init $path
    git submodule update $path
}

##
# Updates the submodule for a path.
##
submodule_service::update_path() {
    local path=${1:?"A submodule path is required"}

    git submodule update --force --checkout --remote $path
}

##
# Gets all installed submodule paths.
##
submodule_service::get_installed_paths() {
    echo $(git submodule foreach --quiet 'echo $sm_path')
}

##
# Removes the submodule repo code from the given submodule path, ignoring any
# local submodule changes.
##
submodule_service::force_remove_repo() {
    local path=${1:?"A submodule path is required"}

    git submodule deinit --force -- $path
}

##
# Removes vestigial submodule path directories.
##
submodule_service::remove_path_directories() {
    local path=${1:?"A submodule path is required"}

    for candidate in $(__submodule_service::get_dir_sequence "$path"); do
        local dir="$__submodule_service_submodules_path/$candidate"

        if [[ -n "$(ls -A $dir 2>/dev/null)" ]]; then
            echo " - skipping non-empty '$candidate'"

            continue
        fi

        echo " - removing empty '$candidate'"

        # remove empty submodule directory
        rm -d "$dir"
        # remove corresponding git module directory
        rm -rf "$__submodule_service_git_path/.git/modules/$candidate"
    done
}

##
# Removes the submodule from the index.
##
submodule_service::force_remove_index() {
    local path=${1:?"A submodule path is required"}

    git rm --force "$path"
}

##
# Removes the configured submodule directory, .git/modules directory and the
# .gitmodules file.
##
submodule_service::remove_config() {
    if [[ -d "$__submodule_service_submodules_path" ]]; then
        rm -d "$__submodule_service_submodules_path"
    fi

    if [[ -f "$__submodule_service_git_path/.gitmodules" ]]; then
        rm "$__submodule_service_git_path/.gitmodules"
    fi

    if [[ -d "$__submodule_service_git_path/.git/modules" ]]; then
        rm -d "$__submodule_service_git_path/.git/modules"
    fi
}

##
# Gets an array of directories, sequentially from the deepest to the nearest to
# the base submodules directory for a submodule path - i.e.:
# - vendor/directory/project-name
# - vendor/directory
# - vendor
##
__submodule_service::get_dir_sequence() {
    local path=${1:?"A submodule path is required"}
    local project=$(echo $path | sed -E "s|^$__submodule_service_submodules_dir/||")
    local submodules_path="$__submodule_service_submodules_path"
    local sequence=()

    for candidate in $(find "$submodules_path" -type d); do
        candidate=$(echo $candidate | sed -E "s|^$submodules_path/||")

        if [[ "$project/" =~ ^"$candidate/" ]]; then
            sequence+=("$candidate")
        fi
    done

    local oldIFS=$IFS && IFS=$'\n'
    local reversed=($(sort -r <<< "${sequence[*]}"))
    IFS=$oldIFS

    echo ${reversed[@]}
}
