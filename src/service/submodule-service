#!/usr/bin/env bash

source "$SERVICE/config-service"

__submodule_service_git_path="$GIT_PATH"
__submodule_service_submodules_dir="$SUBMODULES_DIR"
__submodule_service_submodules_path="$GIT_PATH/$SUBMODULES_DIR"

##
# Recursively adds a git submodule and its dependencies to a project.
##
submodule_service::add() {
    local is_super="$1"
    local options="${@:2}"
    local super_path=$(for option in ${options[@]}; do :; done; echo "$option")

    git submodule add ${options[@]}

    # TODO: add exit here for unsuccesful submodule fetch

    local super=$(config_service::get_name_for_path "$super_path")

    if "$is_super"; then
        config_service::set_as_super "$super"
    fi

    local dependencies=(
        $(__submodule_service::get_dependencies_for_path "$super_path")
    )
    local dependency_path
    for dependency_path in ${dependencies[@]}; do
        dependency_path=${dependency_path/$super_path\/}
        echo "Adding dependency '$dependency_path' for '$super_path'"

        local dependency=$(
            config_service::get_name_for_path "$dependency_path" "$super_path"
        )

        if ! $(config_service::get_configured_paths | grep -q "$dependency_path"); then
            local dependency_options=(
                --branch $(
                    config_service::get_branch_for_path "$dependency_path" "$super_path"
                )
                --name "$dependency"
                --
                $(config_service::get_repo_for_path "$dependency_path" "$super_path")
                "$dependency_path"
            )

            submodule_service::add false "${dependency_options[@]}"
        else
            echo "'$dependency_path' is already required"
        fi

        # update dependency config
        config_service::set_super_dependency "$super" "$dependency_path"
        config_service::set_dependency_super "$dependency" "$super_path"
    done

    git add .gitmodules
}

##
# Removes a submodule and it's dependencies from a project.
##
submodule_service::remove() {
    local path="${1:?"A submodule path is required"}"
    local super_path="$2"

    echo " - removing submodule: '$path'"

    if ! $(__submodule_service::pre_remove "$path" "$super_path"); then
        echo "  -> '$path' is a dependency of at least one other module. Skipping removal!"

        return 1
    fi

    local dependencies=($(__submodule_service::get_dependencies_for_path "$path"))

    local dependency_path
    for dependency_path in ${dependencies[@]}; do
        submodule_service::remove "${dependency_path/$path\/}" "$path"
    done

    __submodule_service::do_remove "$path"
    __submodule_service::post_remove
}

##
# Performs the actual removal of a submodule.
##
__submodule_service::do_remove() {
    local path=${1:?"A submodule path is required"}

    submodule_service::force_remove_repo $path
    submodule_service::remove_path_directories $path
    submodule_service::force_remove_index $path
}

##
# Performs post submodule removal tasks.
##
__submodule_service::post_remove() {
    local remaining=($(config_service::get_configured_paths))

    if [[ ${#remaining[@]} -eq 0 ]]; then
        autoload_service::remove
        submodule_service::remove_config
    fi

    git add .gitmodules
}

##
# Performs pre submodule removal tasks.
##
__submodule_service::pre_remove() {
    local path="${1:?"A submodule path is required"}"
    local super_path="$2"

    local can_remove=$(
        __submodule_service::can_remove_path "$path" "$super_path"
        echo $?
    )
    local name=$(config_service::get_name_for_path "$path")

    # whether or not we can actually remove the path, we need to remove its
    # reference to the super module requesting the path's removal:
    config_service::remove_dependency_super "$name" "$super_path"

    # the above config changes must be staged for further removals to work
    git add .gitmodules

    return $can_remove
}

##
# Determines if a path can be removed, which depends on whether or not it has
# any other governing super modules.
##
__submodule_service::can_remove_path() {
    local path="${1:?"A submodule path is required"}"
    local super_path="$2"

    if [[ -n "$super_path" ]] \
    && [[ $(config_service::path_super_count "$super_path") -gt 0 ]] \
    && ! $(config_service::path_is_dependency_of_super "$super_path"); then
        # the path's super also has a super, so it is _not_ self-governing
        return 1
    fi

    if [[ $(config_service::path_super_count "$path") -gt 1 ]]; then
        # a path with more than one super should still be governed by it
        return 1
    fi

    return $(config_service::path_is_dependency_of_super "$path" "$super_path")
}

##
# Installs the submodule for a path.
##
submodule_service::install_path() {
    local path=${1:?"A submodule path is required"}

    git submodule init $path
    git submodule update $path
}

##
# Updates the submodule for a path.
##
submodule_service::update_path() {
    local path=${1:?"A submodule path is required"}

    git submodule update --force --checkout --remote $path
}

##
# Gets all installed submodule paths.
##
submodule_service::get_installed_paths() {
    echo $(git submodule foreach --quiet 'echo $sm_path')
}

##
# Removes the submodule repo code from the given submodule path, ignoring any
# local submodule changes.
##
submodule_service::force_remove_repo() {
    local path=${1:?"A submodule path is required"}

    git submodule deinit --force -- $path
}

##
# Removes vestigial submodule path directories.
##
submodule_service::remove_path_directories() {
    local path=${1:?"A submodule path is required"}

    for candidate in $(__submodule_service::get_dir_sequence "$path"); do
        local dir="$__submodule_service_submodules_path/$candidate"

        if [[ -n "$(ls -A $dir 2>/dev/null)" ]]; then
            echo " - skipping non-empty '$candidate'"

            break
        fi

        echo " - removing empty '$candidate'"

        # remove empty submodule directory
        rm -d "$dir"
        # remove corresponding git module directory
        rm -rf "$__submodule_service_git_path/.git/modules/$candidate"
    done
}

##
# Removes the submodule from the index.
##
submodule_service::force_remove_index() {
    local path=${1:?"A submodule path is required"}

    git rm --force "$path"
}

##
# Removes the configured submodule directory, .git/modules directory and the
# .gitmodules file.
##
submodule_service::remove_config() {
    if [[ -d "$__submodule_service_submodules_path" ]]; then
        rm -d "$__submodule_service_submodules_path"
    fi

    if [[ -f "$__submodule_service_git_path/.gitmodules" ]]; then
        rm "$__submodule_service_git_path/.gitmodules"
    fi

    if [[ -d "$__submodule_service_git_path/.git/modules" ]]; then
        rm -d "$__submodule_service_git_path/.git/modules"
    fi
}

##
# Gets an array of dependency paths for a given submodule path.
##
__submodule_service::get_dependencies_for_path() {
    local path="${1:?"A path is required"}"
    local states=($(git submodule status --recursive $path))
    local dependencies=()

    for state in "${states[@]}"; do
        case "$state" in
            **/**)
                if [[ "$state" != "$path" ]]; then
                    dependencies+=("$state")
                fi
            ;;
        esac
    done

    echo ${dependencies[@]}
}

##
# Gets an array of directories, sequentially from the deepest to the nearest to
# the base submodules directory for a submodule path - i.e.:
# - vendor/directory/project-name
# - vendor/directory
# - vendor
##
__submodule_service::get_dir_sequence() {
    local path=${1:?"A submodule path is required"}
    local project=$(
        echo $path | sed -E "s|^$__submodule_service_submodules_dir/||"
    )
    local submodules_path="$__submodule_service_submodules_path"
    local sequence=()

    for candidate in $(find "$submodules_path" -type d); do
        candidate=$(echo $candidate | sed -E "s|^$submodules_path/||")

        if [[ "$project/" =~ ^"$candidate/" ]]; then
            sequence+=("$candidate")
        fi
    done

    local oldIFS=$IFS && IFS=$'\n'
    local reversed=($(sort -r <<< "${sequence[*]}"))
    IFS=$oldIFS

    echo ${reversed[@]}
}
