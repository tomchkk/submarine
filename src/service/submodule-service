#!/usr/bin/env bash

##
# Adds a git submodule to a project.
##
submodule_service::add() {
    git submodule add $@
}

##
# Installs the submodule for a path.
##
submodule_service::install_path() {
    local path=${1:?"A submodule path is required"}

    git submodule init $path
    git submodule update $path
}

##
# Updates the submodule for a path.
##
submodule_service::update_path() {
    local path=${1:?"A submodule path is required"}

    git submodule update --force --checkout --remote $path
}

##
# Gets all configured submodule names.
##
submodule_service::get_configured_names() {
    local names=()
    local options=(--file .gitmodules --name-only --get-regexp .path)

    for name in $(git config ${options[@]}); do
        names+=($(echo $name | cut -d '.' -f 2))
    done

    echo ${names[@]}
}

##
# Gets all configured submodule paths.
##
submodule_service::get_configured_paths() {
    local paths=()

    for key in $(__submodule_service::get_keys_for_item "path"); do
        paths+=($(git config --file .gitmodules --get "$key"))
    done

    echo ${paths[@]}
}

##
# Gets all installed submodule paths.
##
submodule_service::get_installed_paths() {
    echo $(git submodule foreach --quiet 'echo $sm_path')
}

##
# Removes the submodule repo code from the given submodule path, ignoring any
# local submodule changes.
##
submodule_service::force_remove_repo() {
    local path=${1:?"A submodule path is required"}

    git submodule deinit --force -- $path
}

##
# Removes vestigial submodule path directories.
##
submodule_service::remove_path_directories() {
    local path=${1:?"A submodule path is required"}

    for candidate in $(__submodule_service::get_dir_sequence "$path"); do
        local dir="$GIT_DIR/$MODULES_DIR/$candidate"

        if [[ -n "$(ls -A $dir 2>/dev/null)" ]]; then
            echo " - skipping non-empty '$candidate'"

            continue
        fi

        echo " - removing empty '$candidate'"

        # remove empty submodule directory
        rm -d "$dir"
        # remove corresponding git module directory
        rm -rf "$GIT_DIR/.git/modules/$candidate"
    done
}

##
# Removes the submodule from the index.
##
submodule_service::force_remove_index() {
    local path=${1:?"A submodule path is required"}

    git rm --force "$path"
}

##
# Finds a submodule path from a submodule name or path value.
##
submodule_service::get_path_for_value() {
    local value="$1"
    local path=$(git config --file .gitmodules --get submodule.$value.path)

    if [[ -n "$path" ]]; then
        echo "$path"

        return 0
    fi

    for path in $(submodule_service::get_configured_paths); do
        if [[ $path =~ ^$value$ ]]; then
            echo "$path"

            return 0
        fi
    done

    return 1
}

##
# Removes the configured submodule directory, .git/modules directory and the
# .gitmodules file.
##
submodule_service::remove_config() {
    if [[ -d "$GIT_DIR/$MODULES_DIR" ]]; then
        rm -d "$GIT_DIR/$MODULES_DIR"
    fi

    if [[ -f "$GIT_DIR/.gitmodules" ]]; then
        rm "$GIT_DIR/.gitmodules"
    fi

    if [[ -d "$GIT_DIR/.git/modules" ]]; then
        rm -d "$GIT_DIR/.git/modules"
    fi
}

##
# Gets a name for a given submodule path, with an optional submodule base path,
# to allow querying of config of installed submodules.
##
__submodule_service::get_name_for_path() {
    local path=${1:?"A path is required"}
    local base=${2:-"./"}

    local config=$(git config --file $base/.gitmodules --get-regexp .path)

    echo "${config[@]}" | grep $path | cut -d ' ' -f 1 | cut -d '.' -f 2
}

##
# Gets the submodule config keys for a given config item.
##
__submodule_service::get_keys_for_item() {
    local item=${1:?"An item key is required"}

    echo $(git config --file .gitmodules --name-only --get-regexp .$item)
}

##
# Gets an array of directories, sequentially from the deepest to the nearest to
# the base submodules directory for a submodule path - i.e.:
# - vendor/directory/project-name
# - vendor/directory
# - vendor
##
__submodule_service::get_dir_sequence() {
    local path=${1:?"A submodule path is required"}
    local project=$(echo $path | sed -E "s|^$MODULES_DIR/||")
    local submodules_dir="$GIT_DIR/$MODULES_DIR"
    local sequence=()

    for candidate in $(find "$submodules_dir" -type d); do
        candidate=$(echo $candidate | sed -E "s|^$submodules_dir/||")

        if [[ "$project/" =~ ^"$candidate/" ]]; then
            sequence+=("$candidate")
        fi
    done

    local oldIFS=$IFS && IFS=$'\n'
    local reversed=($(sort -r <<< "${sequence[*]}"))
    IFS=$oldIFS

    echo ${reversed[@]}
}
