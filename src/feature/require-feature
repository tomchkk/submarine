#!/usr/bin/env bash

##
# Performs a dry-run of a new git submodule require action.
##
require_feature::require_dry_run() {
    local options=$(__require_feature::prepare_options $@)

    cat << EOF
Options for submodule add command:
    ${options[@]}
EOF
}

##
# Requires a new git repo as a submodule.
##
require_feature::require() {
    local options=$(__require_feature::prepare_options $@)

    __require_feature::submodule_add "${options[@]}"
}

##
# Makes the actual git submodule add command.
##
__require_feature::submodule_add() {
    cd "$GIT_DIR" && git submodule add $@
}

##
# Prepares submodule add options.
##
__require_feature::prepare_options() {
    local branch=${1:?"A default branch is required"}
    local repo=${2:?"A repository is required"}
    local name=${3:-"$(__require_feature::parse_name_from_repo $repo)"}

    local options=(
        -b $branch
        # name of submodule - e.g.: git-user/project-name
        --name $name
        --
        $repo
        # path to install submodule in project
        $MODULES_DIR/$name
    )

    echo ${options[@]}
}

##
# Parses a submodule name from the git ssh repo address - i.e.:
# - git@gitlab.com:vendor/project.git -> vendor/project
##
__require_feature::parse_name_from_repo() {
    local name=${1:?"A repo value is required"}

    name=$(echo $name | cut -d ':' -f 2)
    name=${name/.git/}

    echo $name
}
